-- 20260215000100_schema.sql
-- テーブル/インデックス/modified更新トリガ（RLSやRBACはまだ入れない）

create extension if not exists pgcrypto;

-- =========================================
-- 共通: modified 自動更新
-- =========================================
create or replace function public.set_modified()
returns trigger
language plpgsql
as $$
begin
  if (tg_op = 'UPDATE') then
    new.modified := now();
  end if;
  return new;
end;
$$;

-- =========================================
-- users（プロフィール/権限）: auth.users と1:1
-- =========================================
create table if not exists public.users (
  user_id   uuid         primary key references auth.users(id) on delete cascade,
  name      varchar(60)  not null default '',
  email     varchar(254) not null default '',
  role      smallint     not null default 2, -- 0=Admin, 1=Leader, 2=User
  deleted   timestamptz,
  created   timestamptz  not null default now(),
  modified  timestamptz,
  constraint chk_users_role check (role in (0, 1, 2))
);

drop trigger if exists trg_users_set_modified on public.users;
create trigger trg_users_set_modified
before update on public.users
for each row execute function public.set_modified();

-- =========================================
-- items
-- =========================================
create table if not exists public.items (
  id        bigint generated by default as identity primary key,
  item_id   uuid          not null default gen_random_uuid(),
  name      varchar(254)  not null,
  deleted   timestamptz,
  created   timestamptz   not null default now(),
  modified  timestamptz,
  constraint uq_items_item_id unique (item_id)
);

drop trigger if exists trg_items_set_modified on public.items;
create trigger trg_items_set_modified
before update on public.items
for each row execute function public.set_modified();

-- =========================================
-- locations（階層）
-- =========================================
create table if not exists public.locations (
  id                 bigint generated by default as identity primary key,
  location_id        uuid          not null default gen_random_uuid(),
  name               varchar(254)  not null,
  parent_location_id uuid,
  deleted            timestamptz,
  created            timestamptz   not null default now(),
  modified           timestamptz,
  constraint uq_locations_location_id unique (location_id),
  constraint fk_locations_parent
    foreign key (parent_location_id)
    references public.locations(location_id)
    on update cascade
    on delete set null
);

drop trigger if exists trg_locations_set_modified on public.locations;
create trigger trg_locations_set_modified
before update on public.locations
for each row execute function public.set_modified();

-- =========================================
-- tasks（物品移動タスク）
-- =========================================
create table if not exists public.tasks (
  id               bigint generated by default as identity primary key,
  task_id          uuid         not null default gen_random_uuid(),
  date_type        smallint     not null,
  current_status   smallint     not null,
  leader_user_id   uuid         not null,
  from_location_id uuid         not null,
  to_location_id   uuid         not null,
  item_id          uuid         not null,
  quantity         int          not null,
  scheduled_start  timestamptz  not null,
  scheduled_finish timestamptz  not null,
  note             text,
  deleted          timestamptz,
  created          timestamptz  not null default now(),
  modified         timestamptz,

  constraint uq_tasks_task_id unique (task_id),

  constraint fk_tasks_leader
    foreign key (leader_user_id)
    references public.users(user_id)
    on update cascade
    on delete restrict,

  constraint fk_tasks_from_location
    foreign key (from_location_id)
    references public.locations(location_id)
    on update cascade
    on delete restrict,

  constraint fk_tasks_to_location
    foreign key (to_location_id)
    references public.locations(location_id)
    on update cascade
    on delete restrict,

  constraint fk_tasks_item
    foreign key (item_id)
    references public.items(item_id)
    on update cascade
    on delete restrict,

  constraint chk_tasks_quantity_positive check (quantity > 0),
  constraint chk_tasks_schedule_order check (scheduled_finish >= scheduled_start)
);

drop trigger if exists trg_tasks_set_modified on public.tasks;
create trigger trg_tasks_set_modified
before update on public.tasks
for each row execute function public.set_modified();

-- =========================================
-- task_activities（タスク履歴）
-- =========================================
create table if not exists public.task_activities (
  id               bigint generated by default as identity primary key,
  task_id          uuid        not null,
  status           smallint    not null,
  operator_user_id uuid,
  created          timestamptz not null default now(),

  constraint fk_task_activities_task
    foreign key (task_id)
    references public.tasks(task_id)
    on update cascade
    on delete restrict,

  constraint fk_task_activities_operator
    foreign key (operator_user_id)
    references public.users(user_id)
    on update cascade
    on delete set null
);

-- =========================================
-- Indexes（一覧・絞り込み最適化）
-- =========================================
create index if not exists idx_tasks_scheduled_start
  on public.tasks (scheduled_start);

create index if not exists idx_tasks_date_type_start
  on public.tasks (date_type, scheduled_start);

create index if not exists idx_tasks_status_start
  on public.tasks (current_status, scheduled_start);

create index if not exists idx_tasks_item_start
  on public.tasks (item_id, scheduled_start);

create index if not exists idx_tasks_leader_start
  on public.tasks (leader_user_id, scheduled_start);

create index if not exists idx_tasks_from_start
  on public.tasks (from_location_id, scheduled_start);

create index if not exists idx_tasks_to_start
  on public.tasks (to_location_id, scheduled_start);

create index if not exists idx_task_activities_task_created
  on public.task_activities (task_id, created desc);

create index if not exists idx_task_activities_operator_created
  on public.task_activities (operator_user_id, created desc);
