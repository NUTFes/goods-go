-- 20260215000100_schema.sql
-- テーブル/インデックス/modified更新トリガ（RLSやRBACはまだ入れない）
-- 追加:
--   - users.email: 有効レコードのみユニーク（deleted is null）
--   - items.name : 有効レコードのみユニーク（deleted is null）
--   - locations.name: 同一親（同一階層）でのみユニーク（deleted is null）

create extension if not exists pgcrypto;

-- =========================================
-- 共通: modified 自動更新
-- =========================================
create or replace function public.set_modified()
returns trigger
language plpgsql
as $$
begin
  if (tg_op = 'UPDATE') then
    new.modified := now();
  end if;
  return new;
end;
$$;

-- =========================================
-- users（プロフィール/権限）: auth.users と1:1
-- =========================================
create table if not exists public.users (
  user_id   uuid         primary key references auth.users(id) on delete cascade,
  name      varchar(60)  not null default '',
  email     varchar(254) not null,               -- ★ default '' は付けない
  role      smallint     not null default 2,     -- 0=Admin, 1=Leader, 2=User
  deleted   timestamptz,
  created   timestamptz  not null default now(),
  modified  timestamptz,
  constraint chk_users_role check (role in (0, 1, 2))
);

-- （推奨）emailが空白だけを禁止
do $$
begin
  if not exists (
    select 1
    from pg_constraint
    where conname = 'chk_users_email_not_blank'
      and conrelid = 'public.users'::regclass
  ) then
    alter table public.users
      add constraint chk_users_email_not_blank
      check (btrim(email) <> '');
  end if;
end $$;

-- ★ 有効レコードだけ email をユニーク（大小文字無視 + 前後空白無視）
create unique index if not exists uq_users_email_active
  on public.users (lower(btrim(email)))
  where deleted is null;

drop trigger if exists trg_users_set_modified on public.users;
create trigger trg_users_set_modified
before update on public.users
for each row execute function public.set_modified();

-- =========================================
-- items
-- =========================================
create table if not exists public.items (
  id        bigint generated by default as identity primary key,
  item_id   uuid          not null default gen_random_uuid(),
  name      varchar(254)  not null,
  deleted   timestamptz,
  created   timestamptz   not null default now(),
  modified  timestamptz,
  constraint uq_items_item_id unique (item_id)
);

-- （推奨）物品名が空白だけを禁止
do $$
begin
  if not exists (
    select 1
    from pg_constraint
    where conname = 'chk_items_name_not_blank'
      and conrelid = 'public.items'::regclass
  ) then
    alter table public.items
      add constraint chk_items_name_not_blank
      check (btrim(name) <> '');
  end if;
end $$;

-- ★ 有効レコードだけ 物品名 をユニーク（大小文字無視 + 前後空白無視）
create unique index if not exists uq_items_name_active
  on public.items (lower(btrim(name)))
  where deleted is null;

drop trigger if exists trg_items_set_modified on public.items;
create trigger trg_items_set_modified
before update on public.items
for each row execute function public.set_modified();

-- =========================================
-- locations（階層）
-- =========================================
create table if not exists public.locations (
  id                 bigint generated by default as identity primary key,
  location_id        uuid          not null default gen_random_uuid(),
  name               varchar(254)  not null,
  parent_location_id uuid,
  deleted            timestamptz,
  created            timestamptz   not null default now(),
  modified           timestamptz,
  constraint uq_locations_location_id unique (location_id),
  constraint fk_locations_parent
    foreign key (parent_location_id)
    references public.locations(location_id)
    on update cascade
    on delete set null
);

-- （推奨）場所名が空白だけを禁止
do $$
begin
  if not exists (
    select 1
    from pg_constraint
    where conname = 'chk_locations_name_not_blank'
      and conrelid = 'public.locations'::regclass
  ) then
    alter table public.locations
      add constraint chk_locations_name_not_blank
      check (btrim(name) <> '');
  end if;
end $$;

-- ★ 同一階層（同じ親）配下では name を重複禁止（有効レコードのみ）
--   ※ NULLはユニーク判定が特殊なので「親あり」と「root」を分ける
create unique index if not exists uq_locations_sibling_name_active
  on public.locations (parent_location_id, lower(btrim(name)))
  where deleted is null
    and parent_location_id is not null;

-- ★ root階層（parent_location_id is null）同士でも name を重複禁止（有効レコードのみ）
create unique index if not exists uq_locations_root_name_active
  on public.locations (lower(btrim(name)))
  where deleted is null
    and parent_location_id is null;

drop trigger if exists trg_locations_set_modified on public.locations;
create trigger trg_locations_set_modified
before update on public.locations
for each row execute function public.set_modified();

-- =========================================
-- tasks（物品移動タスク）
-- =========================================
create table if not exists public.tasks (
  id               bigint generated by default as identity primary key,
  task_id          uuid         not null default gen_random_uuid(),
  date_type        smallint     not null,
  current_status   smallint     not null,
  leader_user_id   uuid         not null,
  from_location_id uuid         not null,
  to_location_id   uuid         not null,
  item_id          uuid         not null,
  quantity         int          not null,
  scheduled_start  timestamptz  not null,
  scheduled_finish timestamptz  not null,
  note             text,
  deleted          timestamptz,
  created          timestamptz  not null default now(),
  modified         timestamptz,

  constraint uq_tasks_task_id unique (task_id),

  constraint fk_tasks_leader
    foreign key (leader_user_id)
    references public.users(user_id)
    on update cascade
    on delete restrict,

  constraint fk_tasks_from_location
    foreign key (from_location_id)
    references public.locations(location_id)
    on update cascade
    on delete restrict,

  constraint fk_tasks_to_location
    foreign key (to_location_id)
    references public.locations(location_id)
    on update cascade
    on delete restrict,

  constraint fk_tasks_item
    foreign key (item_id)
    references public.items(item_id)
    on update cascade
    on delete restrict,

  constraint chk_tasks_quantity_positive check (quantity > 0),
  constraint chk_tasks_schedule_order check (scheduled_finish >= scheduled_start)
);

drop trigger if exists trg_tasks_set_modified on public.tasks;
create trigger trg_tasks_set_modified
before update on public.tasks
for each row execute function public.set_modified();

-- =========================================
-- task_activities（タスク履歴）
-- =========================================
create table if not exists public.task_activities (
  id               bigint generated by default as identity primary key,
  task_id          uuid        not null,
  status           smallint    not null,
  operator_user_id uuid,
  created          timestamptz not null default now(),

  constraint fk_task_activities_task
    foreign key (task_id)
    references public.tasks(task_id)
    on update cascade
    on delete restrict,

  constraint fk_task_activities_operator
    foreign key (operator_user_id)
    references public.users(user_id)
    on update cascade
    on delete set null
);

-- =========================================
-- Indexes（一覧・絞り込み最適化）
-- =========================================
create index if not exists idx_tasks_scheduled_start
  on public.tasks (scheduled_start);

create index if not exists idx_tasks_date_type_start
  on public.tasks (date_type, scheduled_start);

create index if not exists idx_tasks_status_start
  on public.tasks (current_status, scheduled_start);

create index if not exists idx_tasks_item_start
  on public.tasks (item_id, scheduled_start);

create index if not exists idx_tasks_leader_start
  on public.tasks (leader_user_id, scheduled_start);

create index if not exists idx_tasks_from_start
  on public.tasks (from_location_id, scheduled_start);

create index if not exists idx_tasks_to_start
  on public.tasks (to_location_id, scheduled_start);

create index if not exists idx_task_activities_task_created
  on public.task_activities (task_id, created desc);

create index if not exists idx_task_activities_operator_created
  on public.task_activities (operator_user_id, created desc);
